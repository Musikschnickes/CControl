#!/usr/bin/python

# Code offset in memory
OFFSET = 4

# Token definitions
TOKENS = [
	"IGNORE_0", "INTERN", "PAUSE", "GOTO", "IF", "GOSUB", "RETURN", "IRETURN", # 0
	"SYS", "SLOWMODE", "PUSHBITP", "PUSHBYTEP", "PUSHWORDP", "PEEKBITP", "PEEKBYTEP", "PEEKWORDP", # 8
	"PUSHAD", "PEEKAD", "IGNORE_18", "IGNORE_19", "PUSHWVAL", "PUSHBITV", "PUSHBYTEV", "PUSHWORDV", # 16
	"STOREBIT", "STOREBYTE", "STOREWORD", "LOOKTAB", "PUSHINTERN", "STOREINTERN", "PRINTN", "PRINTS", # 24
	"PUT", "RXD", "GET", "INPUT", "HANDSHAKE", "CTS", "IGNORE_38", "IGNORE_39", # 32
	"NOT", "AND", "NAND", "OR", "NOR", "XOR", "SHL", "SHR", # 40
	"RANDOMIZE", "RAND", "UMIN", "ADD", "SUB", "MUL", "DIV", "MOD", # 48
	"ABS", "SQR", "MAX", "MIN", "GT", "GTE", "LT", "LTE", # 56
	"EQ", "NEQ", "SGN", "IGNORE_67", "IGNORE_68", "IGNORE_69", "FILE", "EOF", # 64
	"BAUD", "INTERRUPT", "JUMP_EQ_B", "JUMP_EQ_W", "ADD_GOTO_B", "ADD_GOTO_W", "IGNORE_78", "IGNORE_79", # 72
	"TOG", "PULSE", "DEACT_BIT", "DEACT_BYTE", "DEACT_WORD", # 80
]

for value in range(0, len(TOKENS)):
	exec("%s = %d" % (TOKENS[value], value))

MAXTOKEN = len(TOKENS)
END = 255

BYTE = [SLOWMODE, PUSHBITP, PUSHBYTEP, PEEKBITP, PEEKBYTEP, PUSHAD, PEEKAD, 
	PUSHBITV, PUSHBYTEV, PUSHWORDV, STOREBIT, STOREBYTE, STOREWORD, PUSHINTERN, 
	STOREINTERN, HANDSHAKE, FILE, BAUD, TOG, PULSE, DEACT_BIT, DEACT_BYTE, ]
WORD = [GOTO, IF, GOSUB, SYS, PUSHWVAL, LOOKTAB, INTERRUPT]

B = "%02x"
W = "%04x"

B = "%d"
W = "%d"

def word(a, b):
	return a << 8 | b

def getTokens(string):
	if string.startswith("CCTRL-BASIC"):
		# Default format, generated by CCUPLWIN.EXE (CCUPLOAD.DAT)
		(header, length, string) = string.strip().replace("\r", "").split("\n", 2)
		
		length = int(length)
		stokens = string.split()
		if length > len(stokens):
			raise Exception("Invalid length. Dump truncated?")
	
		return map(int, stokens)
	elif string.startswith("\x00\x00\x00\x00"):
		# BIN format, used by CCTOKBAS.EXE
		return map(chr, string[4:])
	else:
		raise Exception("Unable to determine input file format")

def dumpCalls(calls, format = "%5d", sep = " "):
	callees = sorted(calls.keys())
	for callee in callees:
		print format % callee + "  " + \
			sep.join([format % caller for caller in calls[callee]])

def decompile(string):
	tokens = getTokens(string)
	data = [False] * len(tokens)
	routines = {}
	jumps = {}
	tables = {}
	variables = {}
	
	inData = False
	
	i = 0
	while i < len(tokens):
		if tokens[i] < MAXTOKEN or tokens[i] == END:
			inData = False
			
		if tokens[i] > MAXTOKEN and tokens[i] != END:
			data[i] = True
			inData = True
			i += 1
		elif not inData and tokens[i] in (GOTO, IF):
			address = word(tokens[i + 1], tokens[i + 2])
			if address not in jumps:
				jumps[address] = []
			jumps[address].append(OFFSET + i)
			i += 3
		elif not inData and tokens[i] in (JUMP_EQ_B, JUMP_EQ_W, ADD_GOTO_B, ADD_GOTO_W):
			address = word(tokens[i + 2], tokens[i + 3])
			if address not in jumps:
				jumps[address] = []
			jumps[address].append(OFFSET + i)
			i += 4
		elif not inData and tokens[i] in (GOSUB, ):
			address = word(tokens[i + 1], tokens[i + 2])
			if address not in routines:
				routines[address] = []
			routines[address].append(OFFSET + i)
			i += 3
		elif not inData and tokens[i] == LOOKTAB:
			address = word(tokens[i + 1], tokens[i + 2])
			if address not in tables:
				tables[address] = []
			tables[address].append(OFFSET + i)
			i += 3
		elif not inData and tokens[i] in (PUSHBITV, PUSHBYTEV, PUSHWORDV):
			var = tokens[i + 1]
			if var not in variables:
				variables[var] = []
			width = 1 if tokens[i] == PUSHBITV else (8 if tokens[i] == PUSHBYTEV else 16)
			variables[var] += [width, OFFSET + i]
			i += 2
		else:
			if tokens[i] in BYTE:
				i += 2
			elif tokens[i] in WORD:
				i += 3
			elif tokens[i] == PRINTS:
				i += 1
				while tokens[i] != 0:
					i += 1
				i += 1
			else:
				i += 1
	
	if True or False:
		print "Routines"
		print "Addr  Called From"
		dumpCalls(routines)
		print
	
		print "Jumps"
		print "Addr  From"
		dumpCalls(jumps)
		print
	
		print "Tables"
		print "Addr  From"
		dumpCalls(tables)
		print
	
		print "Variables"
		print "Addr  Width   From"
		addresses = sorted(variables.keys())
		for addr in addresses:
			widths = variables[addr][0::2]
			print "  %2d   %d %d  " % (addr, min(widths), max(widths)) + \
				" ".join(["%5d" % a for a in variables[addr][1::2]])
		print
	
	return
	
	inTable = False
	i = 0
	while i < len(tokens):
		if tokens[i] >= MAXTOKEN and tokens[i] != END:
			if not inTable:
				print ("TABLE " + W) % (OFFSET + i)
				inTable = True
			print "\t%d" % tokens[i]
			i += 1
		else:
			if inTable:
				print "ENDTABLE"
				inTable = False
			
			if tokens[i] in BYTE:
				print ("%s " + B) % (TOKENS[tokens[i]], tokens[i + 1])
				i += 2
			elif tokens[i] in WORD:
				print ("%s " + W) % (TOKENS[tokens[i]], word(tokens[i + 1], tokens[i + 2]))
				i += 3
			elif tokens[i] in (JUMP_EQ_B, JUMP_EQ_W, ADD_GOTO_B, ADD_GOTO_W):
				print ("%s " + B + " " + W) % (TOKENS[tokens[i]], tokens[i + 1], word(tokens[i + 2], tokens[i + 3]))
				i += 4
			elif tokens[i] == PRINTS:
				i += 1
				s = i
				while tokens[i] != 0:
					i += 1
				print "PRINT \"%s\"" % tokens[s:i]
				i += 1
			elif tokens[i] == END:
				print "END"
				i += 1
			else:
				print "%s" % TOKENS[tokens[i]]
				i += 1
		
	
if __name__ == "__main__":
	decompile(open("program.dat", "r").read())
